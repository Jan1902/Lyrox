using Lyrox.Framework.CodeGeneration.Shared;
using Lyrox.Framework.Core.Abstraction.Networking.Packet;
using System.Reflection;
using Autofac;
using Lyrox.Framework.Networking.Mojang.Data.Abstraction;
using Lyrox.Framework.Networking.Core.Data.Abstraction;

namespace Lyrox.Framework.Networking.Core;

public class PacketSerializer : IPacketSerializer
{
    private IEnumerable<FullPacketMapping> _mappings = new List<FullPacketMapping>();

    private readonly IMinecraftBinaryReaderWriterFactory _readerWriterFactory;

    public PacketSerializer(PacketTypeMapping packetTypeMapping, IMinecraftBinaryReaderWriterFactory readerWriterFactory)
    {
        _readerWriterFactory = readerWriterFactory;

        SetupFullMappings(packetTypeMapping);
    }

    private void SetupFullMappings(PacketTypeMapping packetTypeMapping)
    {
        var mappings = new List<FullPacketMapping>();

        foreach (var (id, packetType) in packetTypeMapping.GetAllPacketMappings())
        {
            if (packetType.GetCustomAttributes<AutoSerializedPacketAttribute>(true).Any())
            {
                var serializationType = Type.GetType($"{packetType.Namespace}.{packetType.Name}_Serialization, {packetType.Assembly.FullName}")
                    ?? throw new Exception("Could not find autogenerated serialization logic");

                mappings.Add(new FullPacketMapping(packetType, id, serializationType));
            }
            else
            {
                var customAttribute = packetType.GetCustomAttributes(true).FirstOrDefault(a => a.GetType().IsClosedTypeOf(typeof(CustomSerializedPacketAttribute<,>)))
                    ?? throw new Exception("Packet definition is missing AutoParsed or CustomParsed attribute");

                mappings.Add(new FullPacketMapping(packetType, id, customAttribute.GetType().GetGenericArguments().Last()));
            }
        }

        _mappings = mappings;
    }

    public int? GetOpCode(Type packetType)
        => _mappings.FirstOrDefault(m => m.PacketType == packetType)?.PacketId;

    public object DeserializePacket(int packetId, IMinecraftBinaryReader reader)
    {
        var mapping = _mappings.FirstOrDefault(m => m.PacketId == packetId)
            ?? throw new Exception("Could not find Serializer Mapping for Packet Type");

        var serializer = Activator.CreateInstance(mapping.SerializerType);
        var deserializeMethodInfo = typeof(IPacketSerializer<>).MakeGenericType(mapping.PacketType).GetMethod(nameof(IPacketSerializer.DeserializePacket))!;

        var packet = deserializeMethodInfo.Invoke(serializer, new[] { reader })!;
        return packet;
    }

    public byte[] SerializePacket(Type packetType, object packet)
    {
        var mapping = _mappings.FirstOrDefault(m => m.PacketType == packet.GetType())
            ?? throw new Exception("Could not find Serializer Mapping for Packet Type");

        var serializer = Activator.CreateInstance(mapping.SerializerType);
        var serializeMethodInfo = typeof(IPacketSerializer<>).MakeGenericType(packetType).GetMethod(nameof(IPacketSerializer.SerializePacket))!;

        using var stream = new MemoryStream();
        using var writer = _readerWriterFactory.CreateBinaryWriter(stream);

        serializeMethodInfo.Invoke(serializer, new[] { writer, packet });

        return stream.ToArray();
    }

    public record FullPacketMapping(Type PacketType, int PacketId, Type SerializerType);
}
